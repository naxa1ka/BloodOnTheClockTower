<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Expressive</name>
    </assembly>
    <members>
        <member name="T:Expressive.Context">
            <summary>
            Represents context related details about compiling and evaluating an <see cref="T:Expressive.Expressions.IExpression"/>.
            </summary>
        </member>
        <member name="P:Expressive.Context.RegisteredFunctions">
            <summary>
            Gets the currently registered functions described by <see cref="T:Expressive.Functions.IFunctionMetadata"/>.
            </summary>
        </member>
        <member name="P:Expressive.Context.RegisteredOperators">
            <summary>
            Gets the currently registered operators described by <see cref="T:Expressive.Operators.IOperatorMetadata"/>.
            </summary>
        </member>
        <member name="M:Expressive.Context.#ctor(Expressive.ExpressiveOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Context"/> class with the specified <paramref name="options"/>.
            </summary>
            <param name="options">The <see cref="T:Expressive.ExpressiveOptions"/> to use when evaluating.</param>
        </member>
        <member name="M:Expressive.Context.#ctor(Expressive.ExpressiveOptions,System.Globalization.CultureInfo,System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Context"/> class with the specified <paramref name="options"/>.
            </summary>
            <param name="options">The <see cref="T:Expressive.ExpressiveOptions"/> to use when evaluating.</param>
            <param name="mainCurrentCulture">The <see cref="T:System.Globalization.CultureInfo"/> for use in general parsing/conversions.</param>
            <param name="decimalCurrentCulture">The <see cref="T:System.Globalization.CultureInfo"/> for use in decimal parsing/conversions.</param>
        </member>
        <member name="M:Expressive.Context.RegisterFunction(System.String,System.Func{Expressive.Expressions.IExpression[],System.Collections.Generic.IDictionary{System.String,System.Object},System.Object},System.Boolean)">
            <summary>
            Registers the supplied <paramref name="function"/> for use within compiling and evaluating an <see cref="T:Expressive.Expression"/>.
            </summary>
            <param name="functionName">The name of the function to register.</param>
            <param name="function">A <see cref="T:System.Func`1"/> to perform the function evaluation.</param>
            <param name="force">Whether to forcefully override any existing function.</param>
        </member>
        <member name="M:Expressive.Context.RegisterFunction(Expressive.Functions.IFunction,System.Boolean)">
            <summary>
            Registers the supplied <paramref name="function"/> for use within compiling and evaluating an <see cref="T:Expressive.Expression"/>.
            </summary>
            <param name="function">The <see cref="T:Expressive.Functions.IFunction"/> to perform the function evaluation.</param>
            <param name="force">Whether to forcefully override any existing function.</param>
        </member>
        <member name="M:Expressive.Context.RegisterOperator(Expressive.Operators.IOperator,System.Boolean)">
            <summary>
            Registers the supplied <paramref name="op"/> for use within compiling and evaluating an <see cref="T:Expressive.Expression"/>.
            </summary>
            <param name="op">The <see cref="T:Expressive.Operators.IOperator"/> implementation to register.</param>
            <param name="force">Whether to forcefully override any existing <see cref="T:Expressive.Operators.IOperator"/>.</param>
            <remarks>
            Please if you are calling this with your own <see cref="T:Expressive.Operators.IOperator"/> implementations do seriously consider raising an issue to add it in to the general framework:
            https://github.com/bijington/expressive
            </remarks>
        </member>
        <member name="M:Expressive.Context.UnregisterFunction(System.String)">
            <summary>
            Removes the function from the available set of functions when evaluating. 
            </summary>
            <param name="functionName">The name of the function to remove.</param>
        </member>
        <member name="M:Expressive.Context.UnregisterOperator(System.String)">
            <summary>
            Removes the operator from the available set of operators when evaluating. 
            </summary>
            <param name="tag">The tag of the operator to remove.</param>
        </member>
        <member name="T:Expressive.Exceptions.ExpressiveException">
            <summary>
            The main exposed <see cref="T:System.Exception"/> for users of an Expression. Check the InnerException for more information.
            </summary>
        </member>
        <member name="T:Expressive.Exceptions.FunctionNameAlreadyRegisteredException">
            <summary>
            Represents an error that is thrown when registering an <see cref="T:Expressive.Functions.IFunction"/> and the name is already used.
            </summary>
        </member>
        <member name="P:Expressive.Exceptions.FunctionNameAlreadyRegisteredException.Name">
            <summary>
            Gets the name of the function already used.
            </summary>
        </member>
        <member name="M:Expressive.Exceptions.FunctionNameAlreadyRegisteredException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Exceptions.FunctionNameAlreadyRegisteredException"/> class.
            </summary>
            <param name="name">The name of the function.</param>
        </member>
        <member name="T:Expressive.Exceptions.MissingParticipantException">
            <summary>
            Represents an error that is thrown when one side of an operation is missing inside an <see cref="T:Expressive.Expression"/>.
            </summary>
        </member>
        <member name="M:Expressive.Exceptions.MissingParticipantException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Exceptions.MissingParticipantException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Expressive.Exceptions.MissingTokenException">
            <summary>
            Represents an error that is thrown when a missing token is detected inside an <see cref="T:Expressive.Expression"/>.
            </summary>
        </member>
        <member name="P:Expressive.Exceptions.MissingTokenException.MissingToken">
            <summary>
            Gets the token that is missing from the <see cref="T:Expressive.Expression"/>.
            </summary>
        </member>
        <member name="M:Expressive.Exceptions.MissingTokenException.#ctor(System.String,System.Char)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Exceptions.MissingTokenException"/> class with a specified error message and missing token.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="missingToken">The token that is missing.</param>
        </member>
        <member name="T:Expressive.Exceptions.OperatorNameAlreadyRegisteredException">
            <summary>
            Represents an error that is thrown when registering an <see cref="T:Expressive.Operators.IOperator"/> and the name is already used.
            </summary>
        </member>
        <member name="P:Expressive.Exceptions.OperatorNameAlreadyRegisteredException.Tag">
            <summary>
            Gets the tag of the operator already used.
            </summary>
        </member>
        <member name="M:Expressive.Exceptions.OperatorNameAlreadyRegisteredException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Exceptions.OperatorNameAlreadyRegisteredException"/> class.
            </summary>
            <param name="tag">The tag of the operator.</param>
        </member>
        <member name="T:Expressive.Exceptions.ParameterCountMismatchException">
            <summary>
            Represents an error that is thrown when a function has an incorrect number of parameters.
            </summary>
        </member>
        <member name="M:Expressive.Exceptions.ParameterCountMismatchException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Exceptions.ParameterCountMismatchException"/> class with a specified error message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Expressive.Exceptions.UnrecognisedTokenException">
            <summary>
            Represents an error that is thrown when a token is not recognised inside an <see cref="T:Expressive.Expression"/>.
            </summary>
        </member>
        <member name="P:Expressive.Exceptions.UnrecognisedTokenException.Token">
            <summary>
            Gets the unrecognised token in the <see cref="T:Expressive.Expression"/>.
            </summary>
        </member>
        <member name="M:Expressive.Exceptions.UnrecognisedTokenException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Exceptions.UnrecognisedTokenException"/> class with a specified unrecognised token.
            </summary>
            <param name="token">The unrecognised token.</param>
        </member>
        <member name="T:Expressive.Expression">
            <summary>
            Class definition for an Expression that can be evaluated.
            </summary>
        </member>
        <member name="P:Expressive.Expression.ReferencedVariables">
            <summary>
            Gets a list of the Variable names that are contained within this Expression.
            </summary>
        </member>
        <member name="P:Expressive.Expression.RegisteredFunctions">
            <summary>
            Gets the currently registered functions described by <see cref="T:Expressive.Functions.IFunctionMetadata"/>.
            </summary>
        </member>
        <member name="P:Expressive.Expression.RegisteredOperators">
            <summary>
            Gets the currently registered operators described by <see cref="T:Expressive.Operators.IOperatorMetadata"/>.
            </summary>
        </member>
        <member name="M:Expressive.Expression.#ctor(System.String,Expressive.ExpressiveOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Expression"/> class with the specified <paramref name="options"/>.
            </summary>
            <param name="expression">The expression to be evaluated.</param>
            <param name="options">The <see cref="T:Expressive.ExpressiveOptions"/> to use when evaluating.</param>
        </member>
        <member name="M:Expressive.Expression.#ctor(System.String,Expressive.Context)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Expression"/> class with the specified <paramref name="context"/>.
            </summary>
            <param name="expression">The expression to be evaluated.</param>
            <param name="context">The <see cref="T:Expressive.Context"/> to use when evaluating.</param>
        </member>
        <member name="M:Expressive.Expression.Evaluate(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Evaluates the expression using the supplied <paramref name="variables"/> and returns the result.
            </summary>
            <exception cref="T:Expressive.Exceptions.ExpressiveException">Thrown when there is a break in the evaluation process, check the InnerException for further information.</exception>
            <param name="variables">The variables to be used in the evaluation.</param>
            <returns>The result of the evaluation.</returns>
        </member>
        <member name="M:Expressive.Expression.Evaluate``1(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Evaluates the expression using the supplied <paramref name="variables"/> and returns the result.
            </summary>
            <exception cref="T:Expressive.Exceptions.ExpressiveException">Thrown when there is a break in the evaluation process, check the InnerException for further information.</exception>
            <param name="variables">The variables to be used in the evaluation.</param>
            <returns>The result of the evaluation.</returns>
        </member>
        <member name="M:Expressive.Expression.Evaluate(Expressive.IVariableProvider)">
            <summary>
            Evaluates the expression using the supplied <paramref name="variableProvider"/> and returns the result.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="variableProvider"/> is null.</exception>
            <exception cref="T:Expressive.Exceptions.ExpressiveException">Thrown when there is a break in the evaluation process, check the InnerException for further information.</exception>
            <param name="variableProvider">The <see cref="T:Expressive.IVariableProvider"/> implementation to provide variable values during evaluation.</param>
            <returns>The result of the evaluation.</returns>
        </member>
        <member name="M:Expressive.Expression.Evaluate``1(Expressive.IVariableProvider)">
            <summary>
            Evaluates the expression using the supplied <paramref name="variableProvider"/> and returns the result.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="variableProvider"/> is null.</exception>
            <exception cref="T:Expressive.Exceptions.ExpressiveException">Thrown when there is a break in the evaluation process, check the InnerException for further information.</exception>
            <param name="variableProvider">The <see cref="T:Expressive.IVariableProvider"/> implementation to provide variable values during evaluation.</param>
            <returns>The result of the evaluation.</returns>
        </member>
        <member name="M:Expressive.Expression.EvaluateAsync(System.Action{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Evaluates the expression using the supplied variables asynchronously and returns the result via the callback.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown if the callback is not supplied.</exception>
            <param name="callback">Provides the result once the evaluation has completed.</param>
            <param name="variables">The variables to be used in the evaluation.</param>
        </member>
        <member name="M:Expressive.Expression.EvaluateAsync``1(System.Action{System.String,``0},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Evaluates the expression using the supplied variables asynchronously and returns the result via the callback.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown if the callback is not supplied.</exception>
            <param name="callback">Provides the result once the evaluation has completed.</param>
            <param name="variables">The variables to be used in the evaluation.</param>
        </member>
        <member name="M:Expressive.Expression.RegisterFunction(System.String,System.Func{Expressive.Expressions.IExpression[],System.Collections.Generic.IDictionary{System.String,System.Object},System.Object})">
            <summary>
            Registers a custom function for use in evaluating an expression.
            </summary>
            <param name="functionName">The name of the function (NOTE this is also the tag that will be used to extract the function from an expression).</param>
            <param name="function">The method of evaluating the function.</param>
            <exception cref="T:Expressive.Exceptions.FunctionNameAlreadyRegisteredException">Thrown when the name supplied has already been registered.</exception>
        </member>
        <member name="M:Expressive.Expression.RegisterFunction(Expressive.Functions.IFunction)">
            <summary>
            Registers a custom function inheriting from <see cref="T:Expressive.Functions.IFunction"/> for use in evaluating an expression.
            </summary>
            <param name="function">The <see cref="T:Expressive.Functions.IFunction"/> implementation.</param>
            <exception cref="T:Expressive.Exceptions.FunctionNameAlreadyRegisteredException">Thrown when the name supplied has already been registered.</exception>
        </member>
        <member name="M:Expressive.Expression.RegisterOperator(Expressive.Operators.IOperator,System.Boolean)">
            <summary>
            Registers the supplied <paramref name="op"/> for use within compiling and evaluating an <see cref="T:Expressive.Expression"/>.
            </summary>
            <param name="op">The <see cref="T:Expressive.Operators.IOperator"/> implementation to register.</param>
            <param name="force">Whether to forcefully override any existing <see cref="T:Expressive.Operators.IOperator"/>.</param>
            <remarks>
            Please if you are calling this with your own <see cref="T:Expressive.Operators.IOperator"/> implementations do seriously consider raising an issue to add it in to the general framework:
            https://github.com/bijington/expressive
            </remarks>
        </member>
        <member name="M:Expressive.Expression.UnregisterFunction(System.String)">
            <summary>
            Removes the function from the available set of functions when evaluating. 
            </summary>
            <param name="functionName">The name of the function to remove.</param>
        </member>
        <member name="M:Expressive.Expression.UnregisterOperator(System.String)">
            <summary>
            Removes the operator from the available set of operators when evaluating. 
            </summary>
            <param name="tag">The tag of the operator to remove.</param>
        </member>
        <member name="M:Expressive.Expressions.Binary.Additive.AddExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.Additive.SubtractExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="T:Expressive.Expressions.Binary.BinaryExpressionBase">
            <summary>
            Base class implementation of <see cref="T:Expressive.Expressions.IExpression"/>.
            </summary>
        </member>
        <member name="P:Expressive.Expressions.Binary.BinaryExpressionBase.Context">
            <summary>
            Gets the underlying <see cref="P:Expressive.Expressions.Binary.BinaryExpressionBase.Context"/>.
            </summary>
        </member>
        <member name="M:Expressive.Expressions.Binary.BinaryExpressionBase.#ctor(Expressive.Expressions.IExpression,Expressive.Expressions.IExpression,Expressive.Context)">
            <summary>
            Initializes a new instance of <see cref="T:Expressive.Expressions.Binary.BinaryExpressionBase"/>.
            </summary>
            <param name="lhs">The left hand <see cref="T:Expressive.Expressions.IExpression"/>.</param>
            <param name="rhs">The right hand <see cref="T:Expressive.Expressions.IExpression"/>.</param>
            <param name="context">The <see cref="P:Expressive.Expressions.Binary.BinaryExpressionBase.Context"/> used during the evaluation.</param>
        </member>
        <member name="M:Expressive.Expressions.Binary.BinaryExpressionBase.Evaluate(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.BinaryExpressionBase.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            The core evaluation logic for the overriding expression implementation.
            </summary>
            <param name="lhsResult">The already evaluated result for the left hand side of the expression.</param>
            <param name="rightHandSide">
            The <see cref="T:Expressive.Expressions.IExpression"/> right hand side of the expression.
            <remarks>
            This is left up to the implementor to evaluate to allow for short-circuiting.
            </remarks>
            </param>
            <param name="variables">The list of variables for use in evaluating.</param>
            <returns>The result of the evaluation.</returns>
        </member>
        <member name="M:Expressive.Expressions.Binary.BinaryExpressionBase.EvaluateAggregates(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object},System.Func{System.Object,System.Object,System.Object})">
            <summary>
            Evaluates the supplied <paramref name="lhsResult"/> and <paramref name="rhs"/> and checks for any possible aggregate value results.
            </summary>
            <param name="lhsResult">The left hand side result.</param>
            <param name="rhs">The <see cref="T:Expressive.Expressions.IExpression"/> right hand side of the expression.</param>
            <param name="variables">The list of variables for use in evaluating.</param>
            <param name="resultSelector">How to return the result(s). <remarks>NOTE this will be called once per aggregate value if they exist.</remarks></param>
            <returns>The result of the evaluation.</returns>
        </member>
        <member name="M:Expressive.Expressions.Binary.Bitwise.BitwiseAndExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.Bitwise.BitwiseExclusiveOrExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.Bitwise.BitwiseOrExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.Bitwise.LeftShiftExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.Bitwise.RightShiftExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.Conditional.NullCoalescingExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.Multiplicative.DivideExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.Multiplicative.ModulusExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Expressions.Binary.Multiplicative.MultiplyExpression.EvaluateImpl(System.Object,Expressive.Expressions.IExpression,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="T:Expressive.Expressions.IExpression">
            <summary>
            Interface definition for an expression that can be evaluated.
            </summary>
            <remarks>
            These are exposed as parameters inside a function.
            </remarks>
        </member>
        <member name="M:Expressive.Expressions.IExpression.Evaluate(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Forces this <see cref="T:Expressive.Expressions.IExpression"/> to be evaluated.
            </summary>
            <param name="variables">The list of variables for use in evaluating.</param>
            <returns>The result of the <see cref="T:Expressive.Expressions.IExpression"/>.</returns>
        </member>
        <member name="M:Expressive.Expressions.VariableExpression.Evaluate(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="T:Expressive.ExpressiveOptions">
            <summary>
            Options to alter the way in which an <see cref="T:Expressive.Expression"/> is parsed and evaluated.
            </summary>
        </member>
        <member name="F:Expressive.ExpressiveOptions.None">
            <summary>
            Specifies that no options are set.
            </summary>
        </member>
        <member name="F:Expressive.ExpressiveOptions.IgnoreCase">
            <summary>
            Specifies case-insensitive matching.
            </summary>
        </member>
        <member name="F:Expressive.ExpressiveOptions.NoCache">
            <summary>
            No-cache mode. Ignores any pre-compiled expression in the cache.
            </summary>
        </member>
        <member name="F:Expressive.ExpressiveOptions.RoundAwayFromZero">
            <summary>
            When using Round(), if a number is halfway between two others, it is rounded toward the nearest number that is away from zero.
            </summary>
        </member>
        <member name="F:Expressive.ExpressiveOptions.IgnoreCaseForParsing">
            <summary>
            Specifies case-insensitive matching for parsing expressions (e.g. function/operator/variable names do not need to match case).
            </summary>
        </member>
        <member name="F:Expressive.ExpressiveOptions.IgnoreCaseForEquality">
            <summary>
            Specifies case-insensitive matching for performing equality comparisons (e.g. THIS == this).
            </summary>
        </member>
        <member name="F:Expressive.ExpressiveOptions.IgnoreCaseAll">
            <summary>
            Specifies case-insensitive matching for both parsing and performing equality comparisons.
            </summary>
        </member>
        <member name="F:Expressive.ExpressiveOptions.All">
            <summary>
            All options are used.
            </summary>
        </member>
        <member name="T:Expressive.Functions.FunctionBase">
            <summary>
            Base class implementation for providing a function that can be registered and evaluated.
            </summary>
        </member>
        <member name="P:Expressive.Functions.FunctionBase.Variables">
            <inheritdoc />
        </member>
        <member name="P:Expressive.Functions.FunctionBase.Name">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Functions.FunctionBase.Evaluate(Expressive.Expressions.IExpression[],Expressive.Context)">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Functions.FunctionBase.ValidateParameterCount(Expressive.Expressions.IExpression[],System.Int32,System.Int32)">
            <summary>
            Validates whether the expected number of parameters are present.
            </summary>
            <param name="parameters">The parameters.</param>
            <param name="expectedCount">The expected number of parameters, use -1 for an unknown number.</param>
            <param name="minimumCount">The minimum number of parameters.</param>
        </member>
        <member name="T:Expressive.Functions.IFunction">
            <summary>
            Interface definition for a Function that can be evaluated.
            </summary>
        </member>
        <member name="P:Expressive.Functions.IFunction.Variables">
            <summary>
            Gets or sets the Variables and their values to be used in evaluating an <see cref="T:Expressive.Expression"/>.
            </summary>
        </member>
        <member name="M:Expressive.Functions.IFunction.Evaluate(Expressive.Expressions.IExpression[],Expressive.Context)">
            <summary>
            Forces the Function to evaluate itself using the supplied parameters.
            </summary>
            <param name="parameters">The list of parameters inside the Function.</param>
            <param name="context">The evaluation context to be used.</param>
            <returns>The result of the Function.</returns>
        </member>
        <member name="T:Expressive.Functions.IFunctionMetadata">
            <summary>
            Interface definition for an <see cref="T:Expressive.Functions.IFunction"/>s metadata.
            </summary>
        </member>
        <member name="P:Expressive.Functions.IFunctionMetadata.Name">
            <summary>
            Gets the name of the Function.
            </summary>
        </member>
        <member name="P:Expressive.Functions.Mathematical.CountFunction.Name">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Functions.Mathematical.CountFunction.Evaluate(Expressive.Expressions.IExpression[],Expressive.Context)">
            <inheritdoc />
        </member>
        <member name="T:Expressive.Helpers.Comparison">
            <summary>
            Helper methods for use when comparing types/values.
            </summary>
        </member>
        <member name="M:Expressive.Helpers.Comparison.CompareUsingMostPreciseType(System.Object,System.Object,Expressive.Context)">
            <summary>
            Performs a comparison of two objects by trying to find the most suitable type and returns
            a value indicating whether one object is less than, equal to, or greater than the other.
            </summary>
            <param name="lhs">The first object to compare.</param>
            <param name="rhs">The second object to compare.</param>
            <param name="context">Any additional <see cref="T:Expressive.Context"/> that may effect the comparion 
            (e.g. string case sensitivity, etc.).</param>
            <returns>A signed integer that indicates the relative values of <paramref name="lhs"/>
            and <paramref name="rhs"/>, as shown in the following table.Value Meaning Less than zero
            <paramref name="lhs"/> is less than <paramref name="rhs"/>.Zero <paramref name="lhs"/> 
            equals <paramref name="rhs"/>. Greater than zero <paramref name="lhs"/> is greater than
            <paramref name="rhs"/>.</returns>
        </member>
        <member name="T:Expressive.Helpers.Numbers">
            <summary>
            Helper class for performing number operations.
            </summary>
        </member>
        <member name="M:Expressive.Helpers.Numbers.Add(System.Object,System.Object)">
            <summary>
            Adds the specified <paramref name="a"/> value to the specified <paramref name="b"/>.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <returns>The result of <paramref name="a"/> + <paramref name="b"/></returns>
        </member>
        <member name="M:Expressive.Helpers.Numbers.Divide(System.Object,System.Object)">
            <summary>
            Divides the specified <paramref name="a"/> value by the specified <paramref name="b"/> value.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <returns>The result of <paramref name="a"/> / <paramref name="b"/>.</returns>
        </member>
        <member name="M:Expressive.Helpers.Numbers.Multiply(System.Object,System.Object)">
            <summary>
            Multiplies the specified <paramref name="a"/> value by the specified <paramref name="b"/> value.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <returns>The result of <paramref name="a"/> * <paramref name="b"/>.</returns>
        </member>
        <member name="M:Expressive.Helpers.Numbers.Subtract(System.Object,System.Object)">
            <summary>
            Subtracts the specified <paramref name="b"/> value from the specified <paramref name="a"/>.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <returns>The result of <paramref name="a"/> - <paramref name="b"/></returns>
        </member>
        <member name="M:Expressive.Helpers.Numbers.Modulus(System.Object,System.Object)">
            <summary>
            Determines the remainder from the specified <paramref name="a"/> value and the specified <paramref name="b"/>.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <returns>The result of <paramref name="a"/> % <paramref name="b"/></returns>
        </member>
        <member name="T:Expressive.Helpers.TypeHelper">
            <summary>
            Helper class to determine <see cref="T:System.Type"/> information.
            </summary>
        </member>
        <member name="M:Expressive.Helpers.TypeHelper.GetTypeCode(System.Object)">
            <summary>
            Gets the underlying type code of the specified <paramref name="value"/>s <see cref="T:System.Type"/>.
            </summary>
            <param name="value">The value to find the underlying <see cref="T:System.TypeCode"/> for.</param>
            <returns>The code of the underlying type, or <see cref="F:System.TypeCode.Empty"/> if type is null.</returns>
        </member>
        <member name="T:Expressive.IVariableProvider">
            <summary>
            Interface definition for providing variable values.
            </summary>
        </member>
        <member name="M:Expressive.IVariableProvider.TryGetValue(System.String,System.Object@)">
            <summary>
            Attempts to safely get the <paramref name="value"/> for the supplied <paramref name="variableName"/>.
            </summary>
            <param name="variableName">The name of the variable.</param>
            <param name="value">The value of the variable or <b>null</b> if it does not exist.</param>
            <returns>true if the variable exists, false otherwise.</returns>
        </member>
        <member name="T:Expressive.Operators.IOperator">
            <summary>
            Definition for all Operators (i.e. +, -, etc.) that are available in Expressive.
            </summary>
        </member>
        <member name="M:Expressive.Operators.IOperator.BuildExpression(Expressive.Token,Expressive.Expressions.IExpression[],Expressive.Context)">
            <summary>
            Builds the operator in to an <see cref="T:Expressive.Expressions.IExpression"/> ready for evaluation.
            </summary>
            <param name="previousToken">The previous <see cref="T:Expressive.Token"/>.</param>
            <param name="expressions">The <see cref="T:Expressive.Expressions.IExpression"/>s to use within the operation (e.g. left hand side and right hand side).</param>
            <param name="context">The <see cref="T:Expressive.Context"/> to use within the operation.</param>
            <returns>An <see cref="T:Expressive.Expressions.IExpression"/> that can be evaluated.</returns>
        </member>
        <member name="M:Expressive.Operators.IOperator.CanGetCaptiveTokens(Expressive.Token,Expressive.Token,System.Collections.Generic.Queue{Expressive.Token})">
            <summary>
            Determines whether this implementation can consume the supplied <see cref="T:Expressive.Token"/>s.
            </summary>
            <param name="previousToken">The previous <see cref="T:Expressive.Token"/>.</param>
            <param name="token">The current <see cref="T:Expressive.Token"/>.</param>
            <param name="remainingTokens">A remaining <see cref="T:Expressive.Token"/>s.</param>
            <returns>True if this implementation can consume the supplied <see cref="T:Expressive.Token"/>s, false otherwise.</returns>
        </member>
        <member name="M:Expressive.Operators.IOperator.GetCaptiveTokens(Expressive.Token,Expressive.Token,System.Collections.Generic.Queue{Expressive.Token})">
            <summary>
            Consume the supplied <see cref="T:Expressive.Token"/>s.
            </summary>
            <param name="previousToken">The previous <see cref="T:Expressive.Token"/>.</param>
            <param name="token">The current <see cref="T:Expressive.Token"/>.</param>
            <param name="remainingTokens">A remaining <see cref="T:Expressive.Token"/>s.</param>
            <returns>The consumed <see cref="T:Expressive.Token"/>s.</returns>
        </member>
        <member name="M:Expressive.Operators.IOperator.GetInnerCaptiveTokens(Expressive.Token[])">
            <summary>
            Gets any nested <see cref="T:Expressive.Token"/>s that can be consumed from within.
            </summary>
            <param name="allCaptiveTokens">All possible <see cref="T:Expressive.Token"/>s to consume.</param>
            <returns>The consumed <see cref="T:Expressive.Token"/>s.</returns>
        </member>
        <member name="M:Expressive.Operators.IOperator.GetPrecedence(Expressive.Token)">
            <summary>
            Gets the <see cref="T:Expressive.Operators.OperatorPrecedence"/>. Basically how important it is over the other implementations.
            </summary>
            <param name="previousToken">The previous <see cref="T:Expressive.Token"/>. Useful for determining whether the operator is unary or binary.</param>
            <returns>The <see cref="T:Expressive.Operators.OperatorPrecedence"/> of this implementation.</returns>
        </member>
        <member name="T:Expressive.Operators.IOperatorMetadata">
            <summary>
            Interface definition for an <see cref="T:Expressive.Operators.IOperator"/>s metadata.
            </summary>
        </member>
        <member name="P:Expressive.Operators.IOperatorMetadata.Tags">
            <summary>
            Gets the list of tags that can be used to identify this IOperator.
            </summary>
        </member>
        <member name="T:Expressive.Operators.OperatorBase">
            <summary>
            Base class implementation of <see cref="T:Expressive.Operators.IOperator"/>.
            </summary>
        </member>
        <member name="P:Expressive.Operators.OperatorBase.Tags">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Operators.OperatorBase.BuildExpression(Expressive.Token,Expressive.Expressions.IExpression[],Expressive.Context)">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Operators.OperatorBase.CanGetCaptiveTokens(Expressive.Token,Expressive.Token,System.Collections.Generic.Queue{Expressive.Token})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Operators.OperatorBase.GetCaptiveTokens(Expressive.Token,Expressive.Token,System.Collections.Generic.Queue{Expressive.Token})">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Operators.OperatorBase.GetInnerCaptiveTokens(Expressive.Token[])">
            <inheritdoc />
        </member>
        <member name="M:Expressive.Operators.OperatorBase.GetPrecedence(Expressive.Token)">
            <inheritdoc />
        </member>
        <member name="T:Expressive.Operators.OperatorPrecedence">
            <summary>
            Enumeration of the different possible precedences of operators (basically the order in which operator gets chosen).
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.Minimum">
            <summary>
            The minimum precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.Or">
            <summary>
            The Or operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.And">
            <summary>
            The And operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.Equal">
            <summary>
            The Equal operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.NotEqual">
            <summary>
            The NotEqual operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.LessThan">
            <summary>
            The LessThan operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.GreaterThan">
            <summary>
            The GreaterThan operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.LessThanOrEqual">
            <summary>
            The LessThanOrEqual operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.GreaterThanOrEqual">
            <summary>
            The GreaterThanOrEqual operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.Not">
            <summary>
            The Not operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.BitwiseOr">
            <summary>
            The BitwiseOr operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.BitwiseXOr">
            <summary>
            The BitwiseXOr operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.BitwiseAnd">
            <summary>
            The BitwiseAnd operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.LeftShift">
            <summary>
            The LeftShift operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.RightShift">
            <summary>
            The RightShift operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.Add">
            <summary>
            The Add operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.Subtract">
            <summary>
            The Subtract operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.Multiply">
            <summary>
            The Multiply operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.Modulus">
            <summary>
            The Modulus operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.Divide">
            <summary>
            The Divide operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.NullCoalescing">
            <summary>
            The NullCoalescing operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.UnaryPlus">
            <summary>
            The UnaryPlus operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.UnaryMinus">
            <summary>
            The UnaryMinus operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.ParenthesisOpen">
            <summary>
            The ParenthesisOpen operator precedence.
            </summary>
        </member>
        <member name="F:Expressive.Operators.OperatorPrecedence.ParenthesisClose">
            <summary>
            The ParenthesisClose operator precedence.
            </summary>
        </member>
        <member name="T:Expressive.Token">
            <summary>
            Represents a chunk of expression that has been identified as something compilable.
            </summary>
        </member>
        <member name="P:Expressive.Token.CurrentToken">
            <summary>
            Gets the text from the expression.
            </summary>
        </member>
        <member name="P:Expressive.Token.Length">
            <summary>
            Gets the length of the text.
            </summary>
        </member>
        <member name="P:Expressive.Token.StartIndex">
            <summary>
            Gets the index where it was discovered in the text.
            </summary>
        </member>
        <member name="M:Expressive.Token.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Expressive.Token"/> class.
            </summary>
            <param name="currentToken">The text from the expression.</param>
            <param name="startIndex">The index where it was discovered in the text.</param>
        </member>
        <member name="T:Expressive.Tokenisation.ITokenExtractor">
            <summary>
            Interface definition for extracting <see cref="T:Expressive.Token"/>s from an expression.
            </summary>
        </member>
        <member name="M:Expressive.Tokenisation.ITokenExtractor.ExtractToken(System.String,System.Int32,Expressive.Context)">
            <summary>
            Extracts a <see cref="T:Expressive.Token"/> from the supplied <paramref name="expression"/>.
            </summary>
            <param name="expression">The expression to extract from.</param>
            <param name="currentIndex">Where to look within the <paramref name="expression"/>.</param>
            <param name="context">Any additional rules to apply when extracting.</param>
            <returns>The <see cref="T:Expressive.Token"/> that is extract, null if extraction fails.</returns>
        </member>
        <member name="T:Expressive.VariableProviderDictionary">
            <summary>
            A 'simple' wrapper around <see cref="T:Expressive.IVariableProvider"/> to allow for it to be used as a dictionary lookup.
            </summary>
        </member>
    </members>
</doc>
